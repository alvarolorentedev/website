"use strict";(self.webpackChunkalvarolorente_dev=self.webpackChunkalvarolorente_dev||[]).push([[1222],{2190:e=>{e.exports=JSON.parse('{"permalink":"/blog/2022/08/08/commiting-like-pro-part-1","editUrl":"https://github.com/alvarolorentedev/website/tree/main/blog/2022-08-08-commiting-like-pro-part-1.md","source":"@site/blog/2022-08-08-commiting-like-pro-part-1.md","title":"Commiting Like a Pro in NodeJs: The hooks","description":"Using git hooks to make sure your commits do what you expect","date":"2022-08-08T00:00:00.000Z","tags":[{"inline":true,"label":"agile","permalink":"/blog/tags/agile"},{"inline":true,"label":"webdev","permalink":"/blog/tags/webdev"},{"inline":true,"label":"programming","permalink":"/blog/tags/programming"},{"inline":true,"label":"productivity","permalink":"/blog/tags/productivity"}],"readingTime":2.28,"hasTruncateMarker":false,"authors":[{"name":"Alvaro Jose","title":"Fractional CTO & Founder","url":"https://github.com/alvarolorentedev","imageURL":"https://avatars.githubusercontent.com/u/3071208","key":"alvarolorentedev","page":null}],"frontMatter":{"title":"Commiting Like a Pro in NodeJs: The hooks","description":"Using git hooks to make sure your commits do what you expect","authors":"alvarolorentedev","tags":["agile","webdev","programming","productivity"],"draft":false,"series":"commiting Like a Pro in NodeJs","canonical_url":"https://www.alvarolorente.dev/blog/2022/08/08/commiting-like-pro-part-1"},"unlisted":false,"prevItem":{"title":"Commiting Like a Pro in NodeJs: The Message","permalink":"/blog/2022/08/09/commiting-like-pro-part-2"},"nextItem":{"title":"Stop doing PR\'s inside the Office","permalink":"/blog/2022/08/08/stop-prs"}}')},4052:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});var i=n(2190),o=n(4848),s=n(8453);const a={title:"Commiting Like a Pro in NodeJs: The hooks",description:"Using git hooks to make sure your commits do what you expect",authors:"alvarolorentedev",tags:["agile","webdev","programming","productivity"],draft:!1,series:"commiting Like a Pro in NodeJs",canonical_url:"https://www.alvarolorente.dev/blog/2022/08/08/commiting-like-pro-part-1"},r=void 0,l={authorsImageUrls:[void 0]},c=[{value:"What &amp; Why Git hooks?",id:"what--why-git-hooks",level:2},{value:"How to Start",id:"how-to-start",level:2},{value:"Add Husky",id:"add-husky",level:3},{value:"Add lint-staged",id:"add-lint-staged",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h2,{id:"what--why-git-hooks",children:"What & Why Git hooks?"}),"\n",(0,o.jsx)(t.p,{children:"Git hooks are scripts that Git executes locally before or after events such as commit, push, and receive."}),"\n",(0,o.jsx)(t.p,{children:"These hooks are completely programmable trough bash scripting. Examples of what can be done:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"pre-commit: Enforce project coding standards."}),"\n",(0,o.jsx)(t.li,{children:"pre-push: Run tests."}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"This allows us to make sure we are committing the correct things at the correct time. Not breaking our code just because of the mental load of doing things as a manual process that can be forgotten."}),"\n",(0,o.jsx)(t.h2,{id:"how-to-start",children:"How to Start"}),"\n",(0,o.jsx)(t.h3,{id:"add-husky",children:"Add Husky"}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.a,{href:"https://typicode.github.io/husky/#/",children:"Husky"})," is a tool that allows Git hooks using JavaScript configured using individual files for hooks in a ",(0,o.jsx)(t.code,{children:".husky/"})," directory."]}),"\n",(0,o.jsxs)(t.p,{children:["The fastest way to install husky is by using ",(0,o.jsx)(t.code,{children:"husky-init"}),", a one-time command to quickly initialize a project with husky:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-sh",children:"npx husky-init && npm install       # npm\nnpx husky-init && yarn              # Yarn 1\nyarn dlx husky-init --yarn2 && yarn # Yarn 2+\npnpm dlx husky-init && pnpm install # pnpm\n"})}),"\n",(0,o.jsx)(t.p,{children:"It will set up husky, modify package.json and create a sample pre-commit hook that you can edit. By default, it will run test when you commit."}),"\n",(0,o.jsxs)(t.p,{children:["To add another hook, use ",(0,o.jsx)(t.code,{children:"husky add"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["If you are not comfortable using  ",(0,o.jsx)(t.code,{children:"husky-init"})," you can find other options ",(0,o.jsx)(t.a,{href:"https://typicode.github.io/husky/#/?id=manual",children:"here"}),"."]}),"\n",(0,o.jsx)(t.h3,{id:"add-lint-staged",children:"Add lint-staged"}),"\n",(0,o.jsx)(t.p,{children:"Husky is very useful, but it will run natively to git and not focus the commands in our bash scripts for all the files, not only the ones we want to commit."}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.a,{href:"https://github.com/okonet/lint-staged",children:"Lint Staged"})," appear to resolve this problem. It allows you to run the process against staged git files that match a pattern."]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.a,{href:"https://asciinema.org/a/199934",children:(0,o.jsx)(t.img,{src:"https://asciinema.org/a/199934.svg",alt:"asciicast"})})}),"\n",(0,o.jsxs)(t.p,{children:["Install ",(0,o.jsx)(t.code,{children:"lint-staged"})," by adding it to your local project."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-sh",children:"npm install lint-staged --save-dev\nyarn add lint-staged -D \n"})}),"\n",(0,o.jsxs)(t.p,{children:["In your package.json add it as a script(",(0,o.jsx)(t.code,{children:'"lint-staged": "lint-staged",'}),") and refer it through a ",(0,o.jsx)(t.code,{children:"pre-commit"})," hook. If using Husky, this can be found in ",(0,o.jsx)(t.code,{children:".husky/pre-commit"})," with the next content:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-sh",children:'#!/bin/sh\n. "$(dirname "$0")/_/husky.sh"\n\nyarn lint-staged\n'})}),"\n",(0,o.jsxs)(t.p,{children:["There are multiple ways to ",(0,o.jsx)(t.a,{href:"https://github.com/okonet/lint-staged#configuration",children:"configure lint-staged"}),". One of them is having a ",(0,o.jsx)(t.code,{children:"lint-staged.config.js"})," file in your project root folder. In this file, you can express what process you want to run for what types of files. For example:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"module.exports = {\n  '*.{ts,tsx}': [() => 'yarn tsc:check', 'yarn format', 'yarn lint:fix', 'yarn test', 'git add .'],\n};\n"})}),"\n",(0,o.jsx)(t.p,{children:"The previous snipped runs the compiler check, formatting, linting and test before adding the fixed staged files to the current commit."}),"\n",(0,o.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(t.p,{children:"With this two tools, we will now be pushing code that will pass similar checks than our CI/CD system."})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>r});var i=n(6540);const o={},s=i.createContext(o);function a(e){const t=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);